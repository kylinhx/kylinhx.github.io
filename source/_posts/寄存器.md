---
title: 寄存器（cpu工作原理）
tags: [Study]
categories: Study
mathjax: true
---



# 寄存器（cpu工作原理）

1、通用寄存器

2、字在寄存器中的存储

3、几条汇编指令

4、物理地址

5、16位结构的cpu

6、8086cpu给出物理地址的方法

7、”段地址*16+偏移地址=物理地址“的本质含义

8、段的概念

9、段寄存器

10、CS和IP

11、代码段

## cpu概述

> 一个典型的cpu由**运算器**、**控制器**、**寄存器**等器件组成，这些器件靠内部总线相连。
> 

区别：

- 内部总线实现cpu内部各个器件之间的联系
- 外部总线实现cpu和主板上其他器件的联系

## 寄存器概述

8086cpu有14个寄存器，他们的名称：

> AX、BX、CX、DX
> 
> 
> SI、DI、
> 
> SP、BP、IP、
> 
> CS、SS、DS、ES、
> 
> PSW
> 

## 1、通用寄存器

8086cpu所有的寄存器都是16位的，可以存放两个字节

- AX、BX、CX、DX 通常用来存放一般性的数据，被称为通用寄存器

![](Untitled.png)

16位数据在寄存器中的存放情况

> 数据：18
> 
> 
> 二进制表示：10010
> 
> 在寄存器AX中的存储：
> 
> ![](Untitled 1.png)
> 

> 数据：20000
> 
> 
> 二进制表示：0100111000100000
> 
> 在寄存器AX中的存储：
> 
> ![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20/Untitled%202.png)
> 

最大值位2^16-1

8086上一代cpu中的寄存器都是8位的，为了保障兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。

- AX可以分为AH和AL（高低位）
- BX可以分为BH和BL
- CX可以分为CH和CL
- DX可以分为DH和DL

8086cpu的8位寄存器存储逻辑

以AX为例，8086CPU的16位寄存器分为两个8位寄存器的情况（AH全为0，只使用AL）

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%203.png)

AL（0-7位）

AH（8-15位）

AL和AH都是可以独立使用的8位寄存器

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%204.png)

## 2、字在寄存器中的存储

一个字（word）可以存在一个16位寄存器中，这个字的高位字节和地位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中

1 word = 2个字节 = 16位           1 字节 = 8位      

关于数制的讨论：

由于一个内存单元可以存放8位数据，cpu中的寄存器又可以存放n个8位数据，也就是说，计算机中的数据大多是由1-N个8位数据构成的。

用16进制来表示数据可以直观的看出这个数据是由哪些8位数据构成的。

每4位（0000-1111）都可以用一个十六进制数（0-E）来表示

十六进制表示的数据后面加上H，在二进制表示的数据后面加B，十进制表示的数据什么也不加

## 3、几条汇编指令

汇编指令不区分大小写

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%205.png)

cpu执行下表中的程序段的每条指令后，对寄存器中的数据进行的改变

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%206.png)

？= 044CH （本来答案是1044C，但是1会溢出）

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%207.png)

？= 0058H   (不是0158H)

这里的丢失，指的是进位制不能在8位寄存器中保存，但是cpu并不是真的丢弃这个进位值

小练习：

（1）

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%208.png)

mov  ax,62627                 AX = F4A3

mov  ah,31H                    AX = 31A3

mov  al,23H                     AX = 31C6

add  ax,ax                        AX = 638C

mov  bx,826CH                BX = 826C

mov  cx,bx                       AX = 4B8C

mov  ax,bx                        AX = 826C

add  ax,bx                        AX = 04D8

mov  al,bh                        AX = 045A

mov  ah,bl                        AX = 705A

add  ah,ah                        AX = E05A

add  al,6                           AX = E060

add  al,al                           AX = E0C0

mov  ax,cx                         AX = 4B8C

（2）只能使用目前学过的汇编指令（mov，add），最多使用4条指令，编程计算2的4次方

> mov  ax,2
> 
> 
> add  ax,ax
> 
> add  ax,ax
> 
> add  ax,ax
> 

## 4、物理地址

cpu访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。

我们将这个唯一的地址称为物理地址

## 5、16位结构的cpu

概括的讲，16位结构描述了一个cpu具有以下几个方面的特征：

- 运算器一次最多可以处理16位的数据。
- 寄存器最大宽度为16位
- 寄存器与运算器之间的通路是16位的

## 6、8086cpu给出物理地址的方法

8086有20位地址总线，可传送20位地址，寻址能力为1M  2^20 = 1MB

8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64KB

8086cpu采用一种再内部用两个16位地址合成的方法来形成一个20位的物理地址

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%209.png)

8086cpu再读写内存时，发生了这么一些事：

> cpu中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址
> 
> 
> 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
> 
> 地址加法器将两个16位的地址合并成一个20位的地址
> 

地址加法器合成物理地址的方法：

物理地址= 段地址*16+偏移地址

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2010.png)

段地址*16 = 地址左移一位 （二进制向左移4位）

（1）一个数据的二进制形式左移1位，相当于该数据乘以2

（2）一个数据的二进制形式左移N位，相当于该数据乘以2的N次方

（3）地址加法器如何完成段地址*16的运算？以二进制形式存放的段地址左移4位

（4）一个数据的X进制形式左移1位，相当于乘以X

## 7、段地址*16 + 偏移地址 = 物理地址 的本质含义

两个比喻说明

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2011.png)

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2012.png)

## 8、段的概念

错误认识：

内存被划分成了一个一个的段，每一个段都有一个段地址

其实：

内存并没有分段，段的划分来自于cpu，由于8086cpu用“（段地址）*16 + 偏移地址 =  物理地址”的方式来给出内存单元的物理地址，使得我们可以用分段的方式来管理内存

以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址*16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。

（1）段地址*16必然是16的倍数，所以一个段的起始地址也一定是16的倍数

（2）偏移地址为16位，16位的寻址能力为64k，所以一个段的长度最大为64k

## 内存单元小结

> cpu访问内存单元时，必须向内存提供内存单元的物理地址。
> 
> 
> 8086cpu在内部用段地址和偏移地址移位相加的方法形成最终的物理地址
> 

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2013.png)

结论：cpu可以用不同的段地址和偏移地址形成同一个物理地址

（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位多少个内存单元

结论：偏移地址16位，变化范围为0~FFFFH，仅通过偏移地址来寻址最多可寻64k个内存单元

## 没有小结的小结

在8086PC机中，存储单元的地址用两个元素来描述，即段地址和偏移地址

“数据在21F60H内存单元中”对于8086PC机的两种描述：

（a）数据存在内存2000:1F60H单元中

（b）数据存在内存的2000段中的1F60H单元中

可根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2014.png)

00010H、1000FH

1001H、2000H

## 9、段寄存器

段寄存器就是提供段地址的

8086cpu有4个段寄存器：

> CS、DS、SS、ES
> 

当8086cpu要访问内存时，由这4个段寄存器提供内存单元的段地址

## 10、CS和IP

CS和IP是8086CPU中最关键的寄存器看，它们指示了CPU当前要读取指令的地址

> CS：代码段寄存器
> 
> 
> IP：指令指针寄存器
> 

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2015.png)

8086pc工作过程的简要概述

（1）从CS：IP指向内存单元读取指令，读取的指令进入指令缓冲器

（2）IP = IP + 所读取指令的长度，从而指向下一条指令

（3）执行指令。转到步骤（1），重复这个过程

> 在8086cpu加点启动或复位后（即cpu刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H
> 
> 
> 即在8086PC机刚启动时，cpu从内存FFFF0H单元中读取指令执行
> 
> FFFF0H单元中的指令是8086PC机开机后执行的第一条指令
> 

在任何时候，cpu将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行

如果说，内存中的一段信息曾被cpu执行过的话，那么，它所在的内存单元必然被CS：IP指向过

## 11、修改CS:IP的指令

在cpu中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对cpu的控制

cpu从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制cpu执行目标指令

mov指令可以改变8086cpu大部分寄存器的值，被称为传送指令

mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能

同时修改CS、IP的内容：

jmp 段地址：偏移地址

jmp 2AE3:3

jmp 3:0B16

仅修改IP的内容：

jmp 某一合法寄存器

mov ax,100

mov bx,200

jmp ax（类似于：mov IP，ax） 

jmp bx

功能：用寄存器中的值修改IP

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2016.png)

> 1、mov ax,6622H
> 
> 
> 2、jmp 1000:3
> 
> 3、mov ax,0000
> 
> 4、mov bx,ax
> 
> 5、jmp bx
> 
> 6、mov ax,0123H
> 
> 7、转到第（3）步执行
> 

## 12、代码段

对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段

可以将长度为N（N≤64KB）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存时用来存放代码的，从而定义了一个代码段

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2017.png)

如何使得代码段中的指令被执行？

将一段内存当作代码段，仅仅是我们在编程时的安排，cpu不会由于这种安排就自动将我们定义的代码段中的指令当作指令来执行

CPU只认被CS:IP指向的内存单元中的内容为指令

所以要将CS:IP指向所定义的代码段中的第一条指令的首地址

## 9-12、小结

1、段地址在8086CPU的寄存器存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址

2、CS存放指令的段地址，IP存放指令的偏移地址

8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行

3、8086cpu的工作过程

> （1）、从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器
> 
> 
> （2）、IP指向下一条指令，IP每次执行完会递加
> 
> （3）、执行指令。（转到步骤（1），重复这个过程）
> 

4、8086CPU提供转移指令（jmp）用来修改CS:IP中的内容

![](%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89%20d78511f6c3584c76aefc1ad023ede984/Untitled%2018.png)

一共修改四次

第一次：读取mov ax,bx之后

第二次：读取sub ax,ax之后

第三次：读取jmp ax之后

第四次：执行jmp ax修改IP

最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H