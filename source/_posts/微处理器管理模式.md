---
title:  微处理器管理模式
tags: [Study]
categories: Study
mathjax: true
---

# 微处理器管理模式

## 3.1微处理器的基本结构

80x86系列处理器成员都采用并行处理技术，即微处理器中有多个处理单元在同一个时间段内协同工作，每个处理单元负责一项工作，并行处理的越多，则微处理器的性能就越高

8086/8088微处理器只有两个处理单元：总线接口单元（BIU）、执行单元（EU）

总线接口单元通过数据总线、地址总线、控制总线来与外部环境联系，包括从存储器中预取指令、读写数据，从I/O接口读写数据以及其他控制功能

数据总线与地址总线时分开的，因此从存储器中存储数据最快也需要在两个时钟周期内完成。

![](Untitled.png)

## 3.2cpu工作模式

从80386开始，32位cpu具有3种运行模式：实模式、保护模式、虚拟8086模式

![](Untitled%201.png)

### 3.2.1实模式

CPU被复位（加电）时，自动进入实模式

实模式不支持硬件上的多任务切换，cpu不能对内存进行分页管理，所有的段都是可以读、写、执行的，同时，实模式不支持特权级，即所有的程序都可以执行特权指令。

在实模式下对一系列的寄存器进行设置，就可以进入保护模式

DOS操作系统运行于实模式下，而Windows和Linux系统运行于保护模式下

### 3.2.2保护模式

找到操作系统进入保护模式

![](Untitled%202.png)

在保护模式下，CPU有4个特权级，分别为特权级0、1、2、3

操作系统运行在高的特权级（Ring 0）上，而应用程序运行在低的特权级（Ring 3）上，应用程序不能直接修改（破坏）操作系统的程序和数据

CPU提供了段式和页式内存管理功能，支持多任务和特权级。
物理寻址空间高达4GB（80386/80486）或64GB（Pentium及以上CPU）

### 3.2.3虚拟8086模式

V86模式是为了在Windows、Linux上运行DOS程序而设计的，它是一种经过修改的保护模式

32位80X86处理器给每个以“虚拟8086模式”运行的任务“创造”了一个与真实的8086处理器十分相似的运行环境，以便运行DOS程序。
既有保护功能又能执行8086代码的工作模式。

## 3.3寄存器

寄存器分为程序可见寄存器组（实模式和保护模式下）和程序不可见寄存器组（保护模式下）

### 3.3.1程序可见寄存器组

80386及其以上型号的cpu能处理32位数据，其寄存器长度是32位的。

程序可见寄存器组包括多个8位、16位和32位寄存器。

> 通用寄存器
> 
> 
> 段寄存器
> 
> 专用寄存器
> 

![](Untitled%203.png)

**3.3.1.1通用寄存器**

![](Untitled%204.png)

**3.3.1.2段寄存器**

![](Untitled%205.png)

段寄存器用来确定一个储存段在内存中的起始地址

（1）代码段寄存器CS：指定当前代码段，代码段中存放当前正在运行的程序段。
（2）堆栈段寄存器SS：指定当前堆栈段。
说明：堆栈段是在内存开辟的一块特殊区域，其中的数据访问原则是后进先出（LIFO），允许插入和删除的一端叫做栈顶。IBM PC机中SP（或ESP）指向栈顶，SS指向堆栈段基地址。

（3）数据段寄存器DS：指定当前运行程序所使用的数据段。
（4）附加数据段寄存器ES：指定当前运行程序所使用的附加数据段。
说明：段寄存器FS和GS：指定当前运行程序的另外两个存放数据的存储段（只对80386以上机器有效）。

说明：虽然DS、ES、FS、GS（甚至于CS、SS）所指定的段中都可以存放数据，但DS是主要的数据段寄存器，在默认情况下使用DS所指向段的数据。若要引用其它段中的数据，通常需要显式说明。

**3.3.1.2专用寄存器**

（1）指令指针寄存器IP/EIP/RIP

指令指针寄存器指向程序的下一条指令

IP代码段内偏移

IP读取指令后，自动移动到另一条指令

（2）堆栈指针寄存器SP/ESP/RSP

堆栈指针，指向栈顶单元

（3）标志寄存器FLAG/EFLAG/RFLAG

用来指示微处理器状态并控制它的操作

![](Untitled%206.png)

运算结果特征标志：用于记录程序中运行结果的特征。8086~Pentium的标志寄存器均含有CF、PF、AF、ZF、SF、OF这6位标志。

1、CF

进位标志，记录运算结果的最高位向前产生的进位或借位。可用于检测无符号数运算时是否发生溢出

> CF=1    有进位或借位
> 
> 
> CF=0    无进位或借位
> 

2、PF

奇偶标志，记录运算结果最低8位中含1的个数。可用于检测数据传送过程中是否发生错误。

> PF＝1 个数为偶数
PF＝0 个数为奇数
> 

3、AF

辅助进位标志，记录运算结果最低4位向前产生的进位或借位。只有在执行十进制运算指令时才关心此位。

> AF＝1	有进位或借位
AF＝0	无进位或借位
> 

4、ZF

零标志，记录运算结果是否为0

> ZF＝1 运算结果为零
ZF＝0 结果非零
> 

5、SF

符号标志，记录运算结果的符号

> SF＝1 运算结果为负
SF＝0 结果非负
> 

6、OF

溢出标志，记录运算结果是否超出了机器所能表示的范围。可用于检测带符号数运算时是否发生溢出。

> OF＝1 运算结果超出范围
OF＝0 结果未超出
> 

**3.3.2保护模式下的特殊寄存器**

![](Untitled%207.png)

> 全局描述符表寄存器GDTR
中断描述符表寄存器IDTR
局部描述符表寄存器LDTR
任务寄存器TR
控制寄存器CR0～CR3
调试寄存器DR0～DR7/
测试寄存器TR6～TR7
> 

**3.3.2 GDTR（Global Descriptor Table Register）**

> 其最低16位是限长，给出全局描述符表（GDT）的字节大小（其值比GDT的长度少1）
其高32位是基址，指出GDT在物理存储器中存放的基地址
LGDT指令可以将描述符表的起始位置装入GDTR
> 

![](Untitled%208.png)

![](Untitled%209.png)

GDT

> 全局存储器是一种共享系统资源，该存储器可以被所有任务访问
全局描述符表GDT是用来定义全局存储器空间的一种机制，它用段描述符说明一个全局存储器中的段，每个GDT最多含有8192个描述符（8192×8＝64KB）
GDT是位于存贮器中，用全局描述符表寄存器GDTR指出它的位置和大小，可软件编程改变
全局描述符表只能有一个
> 

**3.3.2 IDTR（Interrupt Descriptor Table Register）**

> 中断描述符表寄存器48位
其最低16位是限长，给出中断描述符表IDT的字节大小（其值比IDT的长度少1）
其高32位是基址，指出IDT在物理存储器中存放的基地址
> 

![](Untitled%2010.png)

IDT

> IDT中保存的是中断门描述符。每个门描述符包含8字节，IDT最多包含256个门描述符，因为CPU最多支持256个中断。中断门指出的是中断服务程序的入口
> 
> 
> 保护模式下的中断描述符表的功能，类似于实模式下的中断向量表
> 
> > IDT的位置可变，由相应的描述符说明
> 实模式下的中断向量表的地址是固定的，必须在物理地址00000H处
> > 

![](Untitled%2011.png)

说明：GDTR和IDTR的值必须在进入保护模式之前装入

**3.3.2 LDTR（Local Descriptor Table Register）**

> 局部描述符表寄存器/16位寄存器！
保护模式下多任务的环境中每个任务都有一个局部描述符表LDT。
LDT只含有与系统中某一个任务相关的各个段的描述符。
和所有任务有关的公用段的描述符放在全局描述符表GDT中。
每一任务的代码段、数据段、堆栈段与系统其他部分隔离开，达到保护的目的。
> 
> 
> LDTR是一个16位的选择符，包含LDT描述符在GDT中的索引，不直接指出LDT的位置和大小。
> 

![](Untitled%2012.png)

LDT

> 由于每项任务都有自己的LDT（且每项任务只能有一个LDT），因此保护模式的软件系统可能有多个LDT。但GDT只有一个
> 

![](Untitled%2013.png)

## 3.4内存管理

cpu对内部存储器的管理实现任务切换和资源调配。早期16位cpu通过分段的方式对内存进行管理，32位cpu采用分段和分页结合的方式对内存进行管理

**3.4.1实模式下分段管理**

8086/8088CPU有20位地址总线，最大寻址空间2^20=1MB，其物理地址范围为00000H~FFFFFH。

当存储器采用分段管理后，一个内存单元地址要用段基地址和偏移量两个逻辑地址来描述，表示为“段基址：偏移量”。因此程序中给出的内存单元地址只是逻辑地址，而不是物理地址，真正的物理地址要通过cpu部件自动计算得到。物理地址是从微处理器引脚上输出的地址信号所决定的地址空间，也是地址总线的寻址空间。

物理地址的计算方法：

> 10H * 段基址 + 偏移量
> 

![](Untitled%2014.png)

**3.4.2保护模式下分段管理**

实模式下，由“段基址：偏移量”形成的逻辑地址通过地址形成部件转换为物理地址，CPU可对该地址的内存进行数据存取。保护模式下，逻辑地址同样由“段基址：偏移量”格式形成，只不过，原来用来存储段基址的段寄存器不再表示短的起始位置，而是用来表示段选择符，偏移量在保护模式下也是由32位的寄存器或存储器寻址方式给出的。保护模式下，该地址表示形式称为虚拟地址，对应的地址空间称为虚拟地址空间。

![](Untitled%2015.png)

![](Untitled%2016.png)

![](Untitled%2017.png)

1、段描述符

段描述符用于描述代码段、数据段、堆栈段

段限长指出了一个段的最后一个字节的偏移地址

段描述符位于GDT或LDT中，占8字节（64位），由以下几个部分组成

> 段基址（32位）
> 
> 
> 限长（20位）
> 
> 访问权限（8）位
> 
> 属性（4）位
> 

![](Untitled%2018.png)

P（Present）存在位。＝1时表示该段己装入内存；＝0时表示该段没有在内存中，访问这个段会产生段异常。操作系统将某个段从物理内存中交换到磁盘时，设置此位为0。
DPL（Descriptor Privilege Level）描述符特权级。说明这个段的特权级，取值为0～3。
S（System）描述符类型位。=1时，这个段为代码段、数据段或堆栈段；=0时，为系统段描述符。
E（Executable）可执行位，用来区分代码段和数据段。S=1且E=1时，这是一个代码段，可执行。S=1且E=0时，这是一个数据段或堆栈段，不可执行。E=0时，后面的两位为ED和W；若E=1时，后面的两位为C和R。

![](Untitled%2019.png)

ED（Expansion Direction）扩展方向位（对数据段或堆栈段）。=0时，段向上扩展（从低地址向高地址扩展），偏移量小于等于限长。=1时，段向下扩展（从高地址向低地址扩展），偏移量必须大于限长。
W（Writeable）写允许位（对数据段或堆栈段）。=0时，不允许对这个数据段写入；=1时，允许对这个数据段写入。对数据段进行读操作总是被允许的。
C（Conforming）一致位（对代码段）。=0时，这个段不是一致代码段；=1时，这个段是一致代码段。
R（Readable）读允许位（对代码段）。=0时，不允许读这个段的内容；=1时，允许读这个段的内容。对于代码段进行写操作总是被禁止的。
A（Accessed）访问位。＝1表示段己被访问（使用）过；＝0表示段未被访问过。

G（Granularity）粒度位。G＝1时，限长以页为单位；G＝0时，限长以字节为单位。
D（Default Operation Size）默认操作数宽度。D＝1时，为32位数据操作段；D＝1时，为16位数据操作段。
AVL（Available field）可用位。这一位保留给操作系统或应用程序来使用。

限长在描述符中一共占20位，G=1时，限长的内容加上1后就是段所占的页数，1页的大小位2^12 = 4KB；G=0时，限长以字节为单位，限长的内容+1就是段所占的字节数。

![](Untitled%2020.png)

![](Untitled%2021.png)

![](Untitled%2022.png)

![](Untitled%2023.png)

![](Untitled%2024.png)

2、段的属性

3、段描述符高速缓存

## 3.5任务

## 3.6保护

保护模式下设置了0、1、2、3共4个特权级，以区分操作系统程序和应用程序。这种特权级机制阻止了用户程序对操作系统的非法访问，保证高特权级的代码或数据不被低特权级的程序所破坏

### 3.6.2对程序的保护

cpu利用特权级实现对程序执行的控制

（1）、直接转移的保护

（2）、间接转移的保护