---
title:  指令系统
tags: [Study]
categories: Study
mathjax: true
---



# 指令系统

基本概念

指令集和指令系统

指令的构成：操作码（执行什么样的操作，具备什么样的功能）  操作数

## 4.1寻址方式

因为操作数表示比较复杂，寻址方式主要解决怎样从内存中取到数，即cpu按照什么样的方式找到操作数

### 4.1.1与数据有关的寻址方式

以mov指令为例

MOV   目标,源

源→目标

**（1）、立即寻址方式**

操作数直接包含在指令中，紧跟在操作码之后的寻址方式位立即寻址方式

MOV  EAX,3

注意：立即寻址方式只能出现在源操作数的位置。

**（2）、寄存器寻址方式**

操作数直接包含在寄存器中，由指令指定寄存器号的寻址方式

MOV  EBX,EAX

寄存器可以是8位、16位、32位通用寄存器或16位段寄存器，但是CS不能用于目标（容易造成系统崩溃）

**（3）、直接寻址方式**

操作数的有效地址直接包含在指令中的寻址方式

MOV EAX, [00404011H]

实际上不太会写出这样的代码，一个变量最终会加载到内存的什么位置我们事先是不知道的，只有加载到内存后变量的地址才能被得知

MOV EAX,a

MOV EAX,ES:b

a为我们在程序中定义的变量，表示不同的物理地址，只是段内偏移量相同而已

**（4）、寄存器间接寻址方式**

操作数有效地址在基地址寄存器BX、BP或变址寄存器SI、DI中，而操作数在存储器中的寻址方式。

对于386以上的cpu，这种寻址方式允许使用任何32位通用寄存器。

MOV AL,[BX]

其中[BX]为寄存器间接寻址方式，注意它与寄存器寻址方式在汇编格式上的区别

若指令中使用的是BX、SI、DI、EAX、EBX、ECX、EDX、ESI、EDI，则缺省情况操作数在数据段，即它们默认与DS段寄存器配合。
若使用的是BP、EBP、ESP,则缺省情况默认与SS段寄存器配合。
均允许使用段超越前缀

MOV AX,[BP] ;

（SS:[BP]）→AX
若（SS）＝ 2000H，（BP）＝ 80H
（20080H）＝ 12H，（20081H）＝ 56H
物理地址：10H ×（SS）＋（BP）＝ 20080H
执行结果：（AX）＝ 5612H。
利用这种寻址方式再配合修改寄存器内容的指令可以方便地处理一维数组。

A byte  1，2，13，…

LEA BX,A（得到A数组的指针，BX得到A数组的第一个元素）

MOV AX,0

ADD AX,[BX]

ADD BX,1

…

**（5）、寄存器相对寻址方式**

操作数的有效地址是一个基址(BX、BP)或变址寄存器(SI、DI)的内容和指令中给定的一个位移量（disp）之和。
386以上允许使用任何32位通用寄存器。位移量可以是一个字节、一个字、一个双字（386以上）的带符号数。
EA＝（基址＜或变址＞寄存器）＋disp
或：EA＝（32位通用寄存器）+disp

MOV AL,8 [BX]

MOV AL,[BX+8]

A byte  1，2，13，…

LEA BX,0

MOV AX,0

ADD AX,A[BX]

ADD AX,[BX+A]

**（6）、基址变址寻址方式**

操作数的有效地址是一个基址寄存器和一个变址寄存器的内容之和。
386以上允许使用变址部分除ESP以外的任何两个32位通用寄存器组合。

![](Untitled.png)

MOV AL, [BX] [SI]

MOV AL,[BX+SI]

使用这种寻址方式可以访问一维数组,其中BX存放数组起始地址的偏移量，SI存放数组元素的下标乘以元素的长度，下标从0开始计数。

BX基地址，SI变地址

**（7）、相对基址变址寻址方式**

操作数的有效地址是一个基址和一个变址寄存器的内容和指令中给定的一个位移量之和。
386以上CPU允许使用变址部分除ESP以外的任何两个32位通用寄存器组合。位移量可以是一个字节、一个字、一个双字（386以上）的带符号数。

缺省使用段寄存器的情况由基址寄存器决定。
若使用BP、EBP或ESP，缺省与SS配合；若使用BX或其它32位通用寄存器，缺省与DS配合。
允许使用段超越前缀。
即：EA＝（基址寄存器）＋（变址寄存器）＋disp
80386以上支持的32位相对基址变址寻址方式组合如下图。

![](Untitled%201.png)

MOV AL, ARY[BX] [SI]
（DS:[BX+SI+ARY]）→AL
可表示为：
MOV AL, ARY [BX+SI]
或 MOV AL,[BX+SI+ARY]

使用这种寻址方式可以访问形如ARY[3][3]的二维数组，下标从0开始计数。

mov bx,0

mov si,0

add ax,ary[bx][si]

add si,1

…

add bx,3

**（8）、比例变址寻址方式**

这种寻址方式是80386以上的微处理器才提供的。
操作数的有效地址由以下几部分相加组成：基址部分(8个32位通用寄存器)、变址部分（除ESP以外的32位通用寄存器）乘以比例因子、位移量（disp）

比例因子可以是1(缺省值)、2、4或8，1可用来寻址字节数组，2可用来寻址字数组，4可用来寻址双字数组,8可用来寻址4字数组。位移量可以是一个字节、一个双字的带符号数。缺省使用段寄存器的情况由基址寄存器决定。

即：EA＝（基址寄存器）＋（变址寄存器）×比例因子＋disp

比例变址寻址方式组合如下图所示。可以看出，它实际上是386以上CPU存储器操作数寻址方式的通用公式。除比例因子不能单独使用外，其它各项都可以独立存在或以组合形式出现。

例如若只含有第一列或第二列，就变成寄存器间接寻址方式。若含有第一列和第二列,就变成基址变址寻址方式。

![](Untitled%202.png)

例. MOV EAX, ARY[EBX] [ESI]
（DS:[ARY＋EBX＋ESI]）→ EAX
例. MOV CX,[EAX+2*EDX]
（DS:[EAX＋2*EDX]）→ CX
例. MOV EBX,[EBP+ECX*4+10H]
（SS:[EBP+ECX*4+10H]）→ EBX
例. MOV EDX, ES:ARY[4*EBX]
（ES:[ARY＋4*EBX]）→ EDX
使用这种寻址方式可以方便地访问数组，其中变址寄存器的内容等于数组下标，比例因子为元素长度。

### 4.1.2与转移地址有关的寻址方式

## 4.2指令

指令告诉CPU执行什么样的操作及操作数从哪里得到。指令可以用大写、小写或大小写字母混合的方式书写

> 指令的格式和功能
> 
> 
> 指令所影响的标志位
> 
> 指令执行周期
> 
> 指令机器长度
> 

汇编语言是面向机器的，指令和机器码基本上是一一对应的，所以它们的实现取决于硬件

**指令系统**

> 数据传送指令
算术运算指令[2进制/10进制]
逻辑指令
程序控制指令
处理机控制指令
串操作指令
条件字节设置指令
> 

**4.2.1数据传送指令**

数据传送指令可以实现数据、地址、标志的传送。除了目标地址为标志寄存器的传送指令外，本组的其它指令不影响标志。

> 1.通用数据传送指令；
2.堆栈操作指令；
3.输入输出指令；
4.查表转换指令；
5.地址传送指令；
6.标志传送指令；
> 

（1）通用数据传送指令

传送指令 MOV
格式：MOV DST，SRC
功能：SRC（源）→DST（目标）
说明：MOV指令可以实现一个字节、一个字、一个双字的数据传送，
注意：源操作数和目标操作数的数据类型匹配问题，即应同为字节、字或双字型数据。
MOV 指令可实现的数据传送方向如下图所示。

![](Untitled%203.png)

**数据传送规则**：

> 立即数不能作为目标操作数；
立即数不能直接送段寄存器；
目标寄存器不能是CS；
两个段寄存器间不能直接传送；
两个存储单元之间不能直接传送。
> 

例:	MOV AL,5
MOV DS,AX
MOV [BX],AX
MOV ES:VAR,12
MOV WORD PTR [BX],10
MOV EAX,EBX
“WORD PTR”，它明确指出BX所指向的内存单元为字型,立即数12被汇编为16位的二进制数。若要生成8位的二进制数，需要用“BYTE PTR”,这里的类型显式说明是必须的。

（源操作数和目标操作数必须至少有一个类型是确定的）

带符号扩展的数据传送指令 MOVSX（386以上）
格式：MOVSX DST,SRC

功能：SRC→DST，DST空出的位用SRC的符号位填充

说明：DST必须是16位或32位寄存器操作数，SRC可以是8位或16位的寄存器或存储器操作数，但不能是立即数

![](Untitled%204.png)

意义：操作后，作为带符号数来说真值没有发生变化

1111 1111 1111 1110 → -2

1111 1110 → -2

当符号位进行扩展时，数据原始真值不发生变化

带零扩展的数据传送指令 MOVZX(386以上)
格式:MOVZX DST,SRC

功能：SRC→DST，DST空出的位用0填充

说明：DST必须是16位或32位寄存器操作数，SRC可以是8位或16位的寄存器或存储器操作数，但不能是立即数

![](Untitled%205.png)

意义：使得低位数据能够参与到高位运算，其变化后真值不发生变化

交换指令 XCHG
格式：XCHG OPR1,OPR2
功能：交换两个操作数。（这两个操作数不能同时为存储器操作数）
说明：OPR是操作数，操作数可以是8位、16位、32位。该指令可能的组合是：
XCHG 寄存器操作数,寄存器操作数
XCHG 寄存器操作数,存储器操作数
XCHG 存储器操作数,寄存器操作数

例：
设:（AX）＝ 1234H，（BX）＝ 4567H
则:	XCHG AX，BX
执行后（AX）＝ 4567H，（BX）＝ 1234H
由于系统提供了这个指令，因此，采用其他方法交换时，速度将会较慢，并需要占用更多的存储空间，编程时要避免这种情况。

（2）堆栈操作指令

堆栈数据的存取原则是“LIFO”
堆栈段段基址→SS
堆栈栈顶地址→SP/ESP
堆栈用途：对现场数据的保护与恢复、子程	序与中断服务返回地址的保护与恢复等。

进栈指令 PUSH

格式：PUSH  SRC

功能：SP = SP - 2

     SS:SP = (SRC)

说明：SRC可以是16位或32位(386以上)的寄存器操作数或存储器操作数。在80286以上的机器中，SRC还可以是立即数。若SRC是16位操作数，则堆栈指针减2；若SRC是32位操作数，则堆栈指针减4。

![](Untitled%206.png)

出栈指令 POP

格式：POP DST
功能：(DST) = SS:SP
           SP = SP + 2
说明：DST可以是16位或32位(386以上)的寄存器操作数和存储器操作数，也可以是除CS寄存器以外的任何段寄存器。若DST是16位，则堆栈指针加2；若DST是32位，则堆栈指针加4。

![](Untitled%207.png)

![](Untitled%208.png)

实现eax，ebx交换

> PUSH EAX
> 
> 
> PUSH EBX
> 
> POP EAX
> 
> POP EBX
> 

（3）输入输出指令

输入指令  IN

格式： IN ACR,PORT
功能：把外设端口（PORT）的内容传送给累加器（ACR）。
说明：可以传送8位、16位、32位,相应的累加器选择AL、AX、EAX，端口号在0-255之间的时候，端口号可以直接写在指令中；若端口号大于255，则端口号通过DX寄存器间接寻址，即端口号应先放入DX中。

![](Untitled%209.png)

输出指令 OUT

格式：OUT PORT,ACR
功能：把累加器的内容传送给外设端口。
说明：对累加器和端口号的选择限制同IN指令。

![](Untitled%2010.png)

（统一编址与独立编址方式，x86采用独立编址方式）

（4）地址传送指令

传送有效地址指令LEA（Load Effective Address），指令传送的是操作数的地址，而不是操作数本身

传送有效地址指令 LEA
格式：LEA REG,SRC
功能：把源操作数的有效地址送给指定的寄存器。
说明：源操作数必须是存储器操作数。

![](Untitled%2011.png)

例.
LEA SI,TAB
LEA BX,TAB [SI]                   
LEA DI,ASCTAB [BX] [SI]

（5）标志传送指令

这组指令中的POPF，POPFD，SAHF指令影响标志位，其他不影响

16位标志进栈指令  PUSHF（Push Flags Register onto the Stack）

格式：PUSHF

功能：先使堆栈指针寄存器SP-2，然后压入标志寄存器FLAGS的内容到栈顶单元

16位标志出栈指令  POPF （Pop Stack into Flags Register）

格式：POPF

功能：先把堆栈指针所指向的字弹出到FLAGS，然后是堆栈指针寄存器SP+2

标志：影响FLAGS中的所有标志

32位标志进展指令  PUSHFD（Push Eflags Register onto the Stack）

格式：PUSHFD

功能：先使堆栈指针寄存器ESP-4，然后压入标志寄存器EFLAGS的内容到栈顶单元

32位标志出栈指令  POPFD （Pop Stack into Eflags Register）

格式：POPFD

功能：先把堆栈指针所指向的双字弹出到EFLAGS，然后使堆栈指针寄存器ESP+4

标志：影响EFLAGS中的所有标志

（6）算数运算指令

> 二进制算术运算指令
十进制算术运算指令
> 

二进制算数运算指令

1.实现二进制算术运算。
2.操作数和运算结果为二进制。
3.操作数及计算结果:8位、16位、32位无符号或带符号二进制数(在书写指令时可以用十进制形式表示)。
4.带符号数在机器中用补码形式表示，最高位为符号位，0表示正数，1表示负数。

（add指令可以进行带符号数和无符号数计算）

类型转换指令

这类指令实际上是把操作数的最高位进行扩展，用于处理带符号数运算的操作数类型匹配问题。这类指令均不影响标志。

(1).字节扩展成字指令 CBW（convert byte to word）
格式:CBW
功能:把AL寄存器中的符号位值扩展到AH中
例. 

MOV AL,5
CBW ;(AH)＝ 0,AL值不变
MOV AL,80H
CBW ;(AH)＝ 0FFH,AL值不变

(2).字扩展成双字指令 CWD（convert word to double word）

格式: CWD
功能:把AX的符号位值扩展到DX中

(3).双字扩展成四字指令 CDQ
格式：CDQ （386以上）
功能: EAX符号位扩展到EDX中

(4).AX符号位扩展到EAX指令 CWDE
格式: CWDE （386以上）
功能: AX寄存器符号位扩展到EAX高16位

二进制加法指令

任何一条二进制加、减法指令均适用于带符号数和无符号数运算。

(1).加法指令 ADD
格式： ADD DST,SRC
功能：（DST）＋（SRC）→ DST
说明：对操作数的限定同MOV指令。
标志：影响OF、SF、ZF、AF、PF、CF标志
例. 

ADD AL,BL
ADD CL,6
ADD WORD PTR[BX],56
ADD EDX,EAX

01010101

10101010

SF：1   ZF：0   AF：0   PF：1   CF：0   OF：0

说明：

对于两个二进制数进行加法运算，如果把数解释为无符号数，其结果可能是溢出的，而如果把数解释为带符号数,其结果可能是不溢出的，反之也一样。

判定条件：
无符号数相加结果若使CF置1,则表示溢出；
带符号数相加结果若使OF置1,则表示溢出。
一旦发生溢出,结果就不正确了。表3-2以8位数为例说明了这种情况。

![](Untitled%2012.png)

对于情况b：
最高位向前有进位，该进位记录在CF中,7加251应该等于258,但在有效的8位结果中,只看到2，这是因为丢掉了28＝256，所以对于无符号数来讲,通过判断CF＝1，便知该结果是错的。

对于情况c：
因为两同号数相加，和的符号却与加数符号相反.所以对于带符号数来讲，该结果是错的，发生这种情况后系统会置OF＝1，所以可通过OF来判断。

(2).带进位加法指令 ADC
格式: ADC DST,SRC
功能:（DST）＋（SRC）＋ CF → DST
说明: 对操作数的限定同MOV指令,该指令适用于多字节或多字的加法运算。
标志: 影响OF、SF、ZF、AF、PF、CF标志
例. 

ADC AX，35;（AX）＝ (AX)＋35＋CF

(3).加1指令 INC
格式：INC DST
功能：（DST）＋1→DST
标志：除不影响CF标志外，影响其它五个算术运算特征标志。
例. INC BX
例.实现+2操作：

ADD AX，2
INC AX
INC AX

(4).互换并加法指令 XADD(486以上)
格式：XADD DST，SRC
功能: (DST)＋(SRC)→TEMP
(DST)→SRC
TEMP→DST
说明：TEMP是临时变量。该指令执行后,原DST的内容在SRC中,和在DST中。
标志：影响OF、SF、ZF、AF、PF、CF。

二进制减法运算

(1).减法指令 SUB
格式： SUB DST,SRC
功能：（DST）－（SRC）→ DST
标志： 影响OF、SF、ZF、AF、PF、CF标志。
例. SUB AX,35
SUB WORD PTR[BX],56
减法指令执行后若使CF＝1，则对无符号数而言发生了溢出。若使OF＝1，则对带符号数而言发生了溢出。

(2).带借位减法指令 SBB
格式: SBB DST,SRC
功能: (DST)－(SRC)－CF → DST
说明: 除了操作为减外,其它要求同ADC,该指令适用于多字节或多字的减法运算。
标志:影响OF、SF、ZF、AF、PF、CF标志
例. 

SBB AX,35;（AX）＝ (AX)－35－CF

(3).减1指令 DEC
格式： DEC DST
功能：(DST)－1→DST
说明：使用本指令可以很方便地实现地址指针或循环次数的减1修改。
标志：除不影响CF标志外，影响其它五个算术运算特征标志。
例. DEC BX

(4).比较指令 CMP
格式:CMP DST,SRC
功能:(DST)－(SRC)，影响标志位。
说明:这条指令执行相减操作后只根据结果设置标志位，并不改变两个操作数的原值，其它要求同SUB。CMP指令常用于比较两个数的大小。
标志:影响OF、SF、ZF、AF、PF、CF标志
例. CMP AX,[BX]

(5).求补指令 NEG
格式： NEG DST
功能：对目标操作数（含符号位）求反加1，并且
把结果送回目标。即:实现0－(DST)→DST
说明：利用NEG指令可实现求一个数的相反数。
标志：影响OF、SF、ZF、AF、PF、CF标志。其中对CF和OF的影响如下：
    a.对操作数所能表示的最小负数(例若操作数是8位则为－128)求补,原操作数不变,但OF被置1
    b.当操作数为0时，清0 CF。
    c.对非0操作数求补后，置1 CF。

例. 实现0 －（AL）的运算
NEG AL
例. EAX中存放一负数,求该数的绝对值
NEG EAX

二进制乘法指令

(1).无符号乘法指令 MUL
格式：MUL SRCreg／m
功能：实现两个无符号二进制数乘。
说明：该指令只含一个源操作数, 另一个乘数必须事前放在累加器（AX）中。可以实现8位、16位、32位无符号数乘。

具体操作为：
字节型乘法：(AL)×(SRC)8→AX
字型乘法： (AX)×(SRC)16→DX:AX（dx与ax拼接在一起，共同表示32位）
双字型乘法：(EAX)×(SRC)32→EDX:EAX
标志：影响CF、OF、SF、ZF、AF、PF，而只有CF、OF有意义,其它标志不确定。
对CF和OF的影响是:若乘积的高半部分(例字节型乘法结果的AH)为0则对CF和OF清0，否则置CF和OF为1。

> 例.
MOV AL,8
MUL BL                               ;(AL)×(BL),结果在AX中
MOV AX,1234H
MUL WORD PTR [BX]         ;(AX)×([BX]),结果在DX:AX中
MOV AL,80H
SUB AH,AH                         ;清0 AH
MUL BX                              ;(AX)×(BX),结果在DX:AX中
> 

 

(2).带符号乘法指令 IMUL
功能：实现两个带符号二进制数乘。
格式1：IMUL SRCreg／m
说明：这种格式的指令除了是实现两个带符号数相乘且结果为带符号数外，其它与MUL指令相同。所有的80X86 CPU都支持这种格式。

具体操作为：
字节型乘法：(AL)×(SRC)8→AX
字型乘法： (AX)×(SRC)16→DX:AX
双字型乘法：(EAX)×(SRC)32→EDX:EAX
标志：
影响CF、OF、SF、ZF、AF、PF，而只有CF、OF有意义,其它标志不确定。对CF和OF的影响是:若乘积的高半部分为低半部分的符号扩展，则对CF和OF
清0,否则置CF和OF为1。

格式2：IMUL REG,SRCreg／m （286以上）
说明：REG和SRC的长度必须相同,目标操作数REG必须是16位或32位通用寄存器，源操作数SRC可以是寄存器或存储器操作数。
具体操作为：
(REG)16×(SRC)16→REG16
(REG)32×(SRC)32→REG32
格式3：IMUL REG,imm8 （286以上）
格式4：IMUL REG,SRCreg／m ,imm8 （286以上）

二进制除法指令

(1).无符号除法指令 DIV
格式：DIV SRCreg／m
功能：实现两个无符号二进制数除法。
说明：该指令只含一个源操作数，该操作数作为除数使用，注意它不能是立即数。被除数必须事前放在隐含的寄存器中。可以实现8位、16位、32位无符号数除。

![](Untitled%2013.png)

> 例. 实现1000÷25的无符号数除法。
MOV AX,1000
MOV BL,25
DIV BL                 ;(AX)÷(BL)、商在AL中、余数在AH中
> 
> 
> 例. 实现1000÷512的无符号数除法。
> MOV AX,1000
> SUB DX,DX	    ; 清0 DX
> MOV BX,512
> DIV BX                 ;(DX:AX)÷(BX)、商在AX中、余数在DX中
> 

(2).带符号除法指令 IDIV
格式:IDIV SRCreg／m
功能:实现两个带符号二进制数除。
说明:除了是实现两个带符号数相除且商和余数均为带符号数、余数符号与被除数相同外，其它与DIV指令相同。
具体操作同无符号数除法。

> 例. 实现(－1000)÷(＋25)的带符号数除法。
MOV AX,－1000
MOV BL,25
IDIV BL           ;(AX)÷(BL)、商在AL中、余数在AH中
例. 实现1000÷（－512）的带符号数除法。
MOV AX,1000
CWD              ; AX的符号扩展到DX
MOV BX,-512
IDIV BX          ;(DX:AX)÷(BX)、商在AX中、余数在DX中
> 

注意：

若除数为0或商超出操作数所表示的范围（例如字节型除法的商超出8位）会产生除法错中断,此时系统直接进入0号中断处理程序,为避免出现这种情况，必要时在程序中应事先对操作数进行判断。

商是不能超过寄存器的表示范围的

FF*FF+FF-1 = FEFF

（3）位运算指令

位运算指令提供了对二进制位的控制。该系统提供的逻辑指令包括

> 逻辑运算指令
位测试指令
位扫描指令
基本移位指令
循环移位指令
双精度移位指令
> 

1、逻辑运算指令

逻辑运算指令见下表。这些指令的操作数可以是8位、16位、32位,其寻址方式与MOV指令的限制相同。

![](Untitled%2014.png)

> NOT指令可用于把操作数的每一位均变反。
AND指令用于把某位清0（与0相与，也可称为屏蔽某位）、某位保持不变（与1相与）。
TEST指令可用于只测试其值而不改变操作数。
OR指令用于把某位置1(与1相或)、某位保持不变（与0相或) 。
XOR指令用于把某位变反（与1相异或）、某位保持不变（与0相异或）。（相同为0，不同为1）
> 

（字母大小写转换）

XOR指令的用法：
0⊕0 = 0	1⊕1 = 0
1⊕0 = 1	0⊕1 = 1
1.逻辑值相同，运算结果为0；
将某个寄存器清零操作；
2.与1异或，结果相反；
将输入字符进行大小写转换；

**加密解密**
设数据的原始形式为A，密码为B。加密的操作为：
C = A ⊕ B
加密后的数据为C。在不知道密码的情况下，从C不能推断出原始数据A，从而达到保密的目的。
而知道密码B后，从C可以求出A。如何解密？
**不需要借助中间数，使用“异或”运算就能交换两个变量的值？**

XOR  a,b

;b不变,a=a⊕b

XOR  b,a

;b=a,a=a=a⊕b

XOR

;a=b,b=a

位测试指令

从386开始增加了位测试指令,它们包括BT、BTS、BTR和BTC。这些指令首先把指定位的值送给CF标志，然后对该位按照指令的要求操作。

![](Untitled%2015.png)

 位扫描指令

从386开始增加了位扫描指令,它们包括BSF、BSR指令，可用于扫描操作数中第一个含1的位。

1.顺向扫描指令 BSF
格式：BSF DST,RSC
功能：从右向左扫描RSC操作数中第一个含1的位，并把扫描到的第一个含1的位号送DST操作数。若RSC＝0，则DST值不确定。
2.逆向扫描指令 BSR
格式：BSR DST,RSC

基本移位指令

这类指令实现对操作数移位,包括SHL、SAL、SHR和SAR指令。表3-5给出了这组指令。

![](Untitled%2016.png)

逻辑左移，对无符号数的操作

算术左移，对带符号数的操作

> 可以用逻辑移位指令实现无符号数乘除法运算,只要移出位不含1：
SHL DST,n执行后是原数的2^n倍
SHR DST,n执行后是原数的1/2^n
可以用算术移位指令实现带符号数乘除法运算，只要移位操作不改变符号位：
SAL DST,n执行后是原数的2^n倍
SAR DST,n执行后是原数的1/2^n
（只要移出位不含1）
> 

**例. 设无符号数X在AL中，用移位指令实现X×10的运算**

MOV AH,0	;为了保证不溢出,将AL扩展为字
SHL AX,1	        ;求得2X
MOV BX,AX	;暂存2X
MOV CL,2	;设置移位次数
SHL AX,CL	;求得8X
ADD AX,BX	;10X＝8X＋2X

**循环移位指令**

这类指令实现循环移位操作,包括ROL、ROR、RCL、RCR指令。表3-6给出了基本移位指令。

![](Untitled%2017.png)

例. 把CX:BX:AX一组寄存器中的48位数据左移一个二进制位。
SHL	AX,1
RCL	BX,1
RCL	CX,1
在没有溢出的情况下，以上程序实现了2×( CX:BX:AX)→CX:BX:AX的功能。

**程序控制指令**

改变程序执行的顺序，控制程序的流向

> 转移指令
循环指令
子程序调用及返回指令
中断调用及返回指令
> 

（1）与转移地址有关的寻址方式

以8086/8088的无条件转移指令为例

无条件转移指令格式：JMP 目标

功能：无条件转移到目标处

说明：其中的目标有各种寻址方式。这些寻址方式可以被分为段内拍转移和段间转移两类。段内转移只影响指令指针的IP值，段间转移既要影响IP值，也要影响代码段寄存器CS的值

一、段内直接寻址方式

转向的有效地址是当前指令指针寄存器的内容和指令中指定的8位、16位位移量之和，该位移量是一个相对于指令指针的带符号数。

即要转向的有效地址为:

![](Untitled%2018.png)

EA就是要转向的本代码段内指令地址的偏移量。它是通过把IP的当前值加上指令中给出的位移量disp得到的，从而使IP指向下一条要执行的指令，实现段内转移。

若位移量是8位的，则称为短转移，可以实现在距离下条指令的＋127~－128字节范围之内转移

段内无条件短转移指令格式：

jmp  short lab

![](Untitled%2019.png)

若位移量是16位的，则称为近转移,可以实现在距离下条指令的＋32767~－32768(以下简称±32K)字节范围之内转移。

段内无条件近转移指令格式：

jmp  lab

jmp  near ptr lab

![](Untitled%2020.png)

二、段内间接寻址方式

转向的有效地址在一个寄存器或内存单元中，该寄存器号或内存地址按上节介绍的与操作数有关的寻址方式（立即寻址方式）获得。所得到的有效地址送给ip，于是实现转移。指令格式举例见下表

![](Untitled%2021.png)

具体说明。
设：

（DS）＝ 2000H，（BX）＝0300H
（IP）＝0100H，（20300H）＝0
（20301H）＝0005H
则： JMP BX          ;执行后（IP）＝（BX）＝ 0300H

例2. JMP WORD PTR [BX]
说明：式中WORD PTR [BX]表示BX指向一个字型内存单元。
1.这条指令执行时，先按照操作数寻址方式得到存放转移地址的内存单元：
10H ×（DS）＋（BX）＝ 20300H
2.再从该单元中得到转移地址：
EA＝（20300H）＝ 0500H
3.于是，(IP)＝EA＝0500H,下一次便执行CS:500H处的指令,实现了段内间接转移。

三、段间寻址方式

指令中直接给出转向的4字节的偏移量和基地址，只需把它们分别送给ip和cs后即可实现段间转移

指令格式：JMP  FAR  PTR  LAB

下图给出的是段间直接转移指令机器码示意图。执行时把偏移量送给IP，段基址送给CS，即可实现段间直接转移。

![](Untitled%2022.png)

四、段间间接寻址方式

用一个双字内存变量中的低16位取代IP值，高16位取代CS值，从而实现段间转移。该双字变量的地址可以由除立即寻址和寄存器寻址方式以外的其他与数据有关的寻址方式获得

具体数据说明：
设：（DS）＝ 2000H，（BX）＝ 0300H
（IP）＝ 0100H，

（20300H）＝ 0
（20301H）＝ 05H
（20302H）＝ 10H
（20303H）＝ 60H
则： JMP DWORD PTR [BX]
说明:式中DWORD PTR [BX]表示BX指向一个双字变量。

这条指令执行时，先按照与操作数有关的寻址方式得到存放转移地址的内存单元：
10H×（DS）＋（BX）＝ 20300H
再把该单元中的低字送给IP，高字送给CS，即0500H →IP，6010H→CS,下一次便执行6010:0500H处的指令，实现了段间间接转移。

上边介绍的与转移地址有关的寻址方式完全适用于386以上的实模式环境。保护模式下的虚拟8086方式转移地址的形成与此类似，只是32位的偏移量送给EIP，但高16位清0，这是因为段长不能超过64K的缘故。

对于32位的保护模式，其段内转移的目标地址的形成与以上所介绍的16位机相比较没有太大变化，只是偏移量为32位、并把该偏移量送给EIP指令指针寄存器而已。
而段间转移的目标地址采用48位全指针形式，即32位的偏移量和16位的段选择子。段间转移的目标地址的形成比较复杂，需要涉及到任务门、调用门等知识。

一、转移指令

这类指令包括无条件转移指令和条件转移指令

1、无条件转移指令JMP

格式：JMP  DST

功能：无条件转移到DST所指向的地址

说明：DST为转移的目标地址（或称转向地址），使用与转移地址有关的寻址方式可以形成目标地址

> 段内转移（IP）
> 
> 
> > 段内直接短转移           JMP   SHORT  LABEL
> > 
> > 
> > 段内直接转移               JMP   NEAR  PTR  LABEL
> > 
> > 段内间接转移               JMP   REG/M
> > 
> 
> 段间转移（CS:IP）
> 
> > 段间直接转移               JMP  FAR  PTR  LABEL
> > 
> > 
> > 段间间接转移               JMP  DWORD  PTR  M
> > 

2、条件转移指令

执行这类指令时，通过检测由前边指令已设置的标志位确定是否转移，所以它们通常是跟在影响标志的指令之后，这类指令本身并不影响标志。

条件转移指令的通用汇编格式：Jcc   LABEL

JCC LABEL
功能：如果条件为真,则转向标号处，否则顺序执行下一条指令。
说明：其中cc为条件,LABEL是要转向的标号。在8086~80286中，该地址应在与当前IP值的－128~＋127范围之内,即只能使用与转移地址有关的寻址方式的段内短转移格式，其位移量占用一个字节。

⑴ 检测单个标志位实现转移的条件转移指令
这组指令根据一个标志位的设置情	况决定是否转移。

![](Untitled%2023.png)

![](Untitled%2024.png)

![](Untitled%2025.png)

⑵ 根据两个带符号数比较结果实现转移的条件转移指令
利用上表中提供的指令，可以实现两个带符号数的比较转移。

![](Untitled%2026.png)

⑶ 根据两个无符号数比较结果实现转移的条件转移指令
利用上表中提供的指令，可以实现两个无符号数的比较转移。

![](Untitled%2027.png)

![](Untitled%2028.png)

3. 测试CX／ECX值为0转移指令
这类指令不同于以上介绍的条件转移指令,因为它们测试的是CX或ECX寄存器的内容是否为0，而不是测试标志位。这类指令只能使用与转移地址有关的寻址方式的段内短转移格式，即位移量只能是8位的。

格式： 

JCXZ LABEL                 ;适用于16位操作数
JECXZ LABEL               ;适用于32位操作数
功能：测试CX(或ECX)寄存器的内容,当CX（或ECX）＝ 0时则转移，否则顺序执行。
说明：此指令经常用于在循环程序中判断循环计数的情况。

例.设M＝(EDX:EAX),N＝(EBX:ECX),比较两个64位数，若M＞N，则转向DMAX，否则转向DMIN。

若两数为无符号数	       若两数为带符号数
则程序片断为：	       则程序片断为：
CMP EDX,EBX	               CMP EDX,EBX
JA DMAX	                       JG DMAX
JB	DMIN	               JL DMIN
CMP EAX,ECX	               CMP EAX,ECX
JA	DMAX	               JA DMAX
DMIN: …	                       DMIN: …
DMAX: …	                       DMAX: …

二、循环指令

循环指令可以控制程序的循环。它们的特点是：

1、用CX或ECX（操作数长度为32位时）作为循环次数计数器

2、不影响标志

1．循环指令 LOOP
格式：LOOP LABEL
功能：(CX)－1→CX，若(CX)≠0，则转向标号处执行循环体，否则顺序执行下一条指令。
说明：若操作数长度为32位，则其中的CX应为ECX。在LOOP指令前，应先把循环计数的初始值送给CX（或ECX）。
2．相等循环指令 LOOPE/LOOPZ
3．不等循环指令 LOOPNE/LOOPNZ

例. 用累加的方法实现M×N，并把结果保存到RESULT单元。
           MOV AX,0	                            ;清0累加器
           MOV BX,M
           CMP BX,0
           JZ TERM	                            ;被乘数为0转
           MOV CX,N
           JCXZ TERM	                            ;乘数为0转
L1:	   ADD AX,BX
           LOOP L1
TERM: MOV RESULT,AX	                    ;保存结果

三、子程序调用与返回指令

![](Untitled%2029.png)

子程序的作用；
子程序的执行流程；

1．子程序调用指令 CALL
格式：CALL DST
功能：调用子程序。执行时先把返回地址压入堆栈，再形成子程序入口地址，最后把控制权交给子程序。

说明：其中DST为子程序名或子程序入口地址，其目标地址的形成与JMP指令有异同。
与JMP指令相同点：
段内直接／间接调用、
段间直接／间接调用、
只是不能使用段内直接寻址方式的SHORT格式。
指令的执行结果是无条件转到标号处
与JMP指令不同点：
CALL转移后要返回，所以要保存返回地址；
JMP转移后不再返回,所以不必保存返回地址。

⑴ 段内调用
这类调用指令实现同一段内的子程序调用,它只改变IP值，不改变CS值。
执行操作：
把返回地址（CALL之后的那条指令地址的偏移量部分(当前IP值)）压入堆栈。
根据与转移地址有关的寻址方式形成子程序入口地址的IP值。
把控制无条件转向子程序，即执行CS:IP处的指令。

① 段内直接调用：
格式：CALL PROCEDURE
或： CALL NEAR PTR PROCEDURE
功能：调用PROCEDURE子程序。执行时先把返回地址压入堆栈,再使IP＝(IP)＋disp16，最后把控制权交给子程序。
② 段内间接调用：
格式：CALL REG／M
功能：调用子程序。执行时先把返回地址压入堆栈，再把指令指定的16位通用寄存器或内存单元的内容送给IP，最后把控制权交给子程序。

例. 可以把子程序入口地址的偏移量送给通用寄存器或内存单元，通过它们实现段内间接调用。
CALL  WORD  PTR  BX                                ;子程序入口地址的偏移量在BX中
CALL  WORD  PTR  [BX]                              ;子程序入口地址的偏移量在数据段的BX所指
                                                                   ;向的内存单元中
CALL  WORD  PTR  [BX][SI]                        ;子程序入口地址的偏移量在数据段的BX＋SI
                                                                   ;所指向的内存单元中

⑵ 段间调用
这类调用指令可以实现段间调用（FAR型调用）,执行时即要改变IP值，也要改变CS值。

① 段间直接调用：
格式：CALL FAR PTR PROCEDURE	
功能：调用PROCEDURE子程序。执行时先把返回地址(当前IP值和当前CS值)压入堆栈，再把指令中的偏移量部分送给IP，段基址部分送给CS，最后把控制权交给子程序。
② 段间间接调用：
格式：CALL M
功能：调用子程序。执行时先把返回地址(当前IP值和当前CS值)压入堆栈，再把M的低字送给IP，高字送给CS,最后把控制权交给子程序。

例. 若子程序B的入口地址(偏移量和段基址)放在变量VAR中,即可通过VAR实现段间间接调用。如下所示：
CALL DWORD PTR VAR                             ;从VAR变量中得到子程序B的入口地址实现调用。
变量VAR的地址也可以通过寄存器间接寻址方式、基址变址寻址方式等存储器操作数寻址方式得到
例. CALL DWORD PTR 8[BX][DI]

1．子程序返回指令 RET
执行这组指令可以返回到被调用处。有两条返回指令，它们都不影响标志。以下介绍8086／8088的子程序调用指令。

(1) 返回指令 RET
格式：RET
功能：按照CALL指令入栈的逆序，从栈顶弹出返回地址（弹出一个字到IP，若子程序是FAR型还需再弹出一个字到CS），然后返回到主程序继续执行。
无论子程序是NEAR型还是FAR型，返回指令的汇编格式总是用RET表示。但经汇编后会产生不同的机器码。在DEBUG中，段间返回指令被反汇编成RETF。

(2) 带立即数的返回指令
格式：RET imm16
功能：按照CALL指令入栈的逆序，从栈顶弹出返回地址（弹出一个字到IP，若子程序是FAR型还需再弹出一个字到CS）,返回到主程序，并修改栈顶指针SP＝(SP)＋imm16。
注：其中imm16是16位的立即数,设通过堆栈给子程序传递了n个字型参数，则imm16＝2n。
修改堆栈指针是为了废除堆栈中主程序传递给子程序的参数。

四、中断调用与返回指令

中断就是使计算机暂时挂起正在执行的进程而转去处理某种事件，处理完后再恢复执行原进程的过程。
对某事件的处理实际上就是去执行一段例行程序，该程序被称为中断处理例行程序或中断处理子程序，简称为中断子程序。

1．中断向量
中断向量就是中断处理子程序的入口地址。在PC机中规定中断处理子程序为FAR型，所以每个中断向量占用4个字节，其中低两个字节为中断向量的偏移量部分,高两个字节为中断向量的段基址部分。
2．中断类型号
IBM PC机共支持256种中断，相应编号为0~255，把这些编号称为中断类型号。

3．中断向量表
256种中断有256个中断向量。把这些中断向量按照中断类型号由小到大的顺序排列，形成中断向量表。
表长为4×256＝ 1024字节，该表从内存的0000:0000地址开始存放，从内存最低端开始存放。

![](Untitled%2030.png)

4．中断调用指令 INT
在8086／8088中,中断分为内中断(或称软中断)和外中断(或称硬中断),本节只介绍内中断的中断调用指令。
格式：INT n	；n为中断类型号
功能：中断当前正在执行的程序，把当前的FLAGS、CS、IP值依次压入堆栈(保护断点）,并从中断向量表的4n处取出n类中断向量.
其中(4n)→IP,(4n+2)→CS，转去执行中断处理子程序。

例. INT 21H
21H为系统功能调用中断,执行时把当前的FLAGS、CS、IP值依次压入堆栈,并从中断向量表的84H处取出21H类中断向量，其中(84H)→IP,(86H)→CS,转去执行中断处理子程序。
例. INT 3 ;断点中断

5．中断返回指令 IRET
格式：IRET
功能：从栈顶弹出三个字分别送入IP、CS、FLAGS寄存器,把控制返回到原断点继续执行。