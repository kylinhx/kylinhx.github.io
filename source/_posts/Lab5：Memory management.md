---
title: Lab5:Memory management
tags: [Code,C,xv6]
categories: Study
mathjax: true
---

# Lab5：*Memory management*

------

## 实验目的：

修改内存布局以将堆栈移动到地址空间的顶部；实现栈的增长。

## 实验过程：

修改xv6的内存布局，在exec.c中通过allocuvm函数重新进行对栈的的地址空间的映射，将其置于高地址位置。实现栈的增长，当有进程申请分配更多的页时，在trap.c中加入T_PGFLT的case

## 实验背景准备和一些学习笔记：

#### 1、i386页面大小的问题

在32位i386系统上，页面固定大小是4kb

#### 2、在页面管理上，系统必须管理所有的物理内存空间。

对于已经存在在内核中的一些实模式数据(如 Real Mode IDT)和系统区域(如 BIOS 数据，显存区域等)，系统不能把它们当作空闲内存分配出去给其他进程使用；而对于内核本身所在的区域，当然也不能把它当做空闲区分配出去给其他进程使用，而且同时,还需要建立起合适的映射关系，达到将逻辑地址转换到物理地址的目标(始终记住：内核程序的逻辑地址是从 KERNBASE=0xF0000000 开始的！)。在确定了页面大小和分页的范围后，物理内存里应该分多少个页面就很清楚了：应该拿物理内存的大小去整除 4KB，即页面的数目(npages) = 物理内存的大小>>12

#### 3、xv6内存管理学习笔记

（1）执行main.c之前的物理内存分布

```
0x0000-0x7c00     引导程序的栈
0x7c00-0x7d00     引导程序的代码(512字节)
0x10000-0x11000   内核ELF文件头(4096字节)
0xA0000-0x100000  设备区
0x100000-0x400000 Xv6操作系统(未用满)
```

（2）Kinit函数

```c++
int
main(void)
{
  kinit1(end, P2V(4*1024*1024)); // phys page allocator
  kvmalloc();      // kernel page table
  //....
}
```

这是main函数的开始。这里的end地址就是kernel从`0x80100000`开始。然后是内核的代码段 + 只读数据段+ stab段+ stabstr + 数据段 + .bss段这些之后的起始地址。如下图所示。

![](image-20210817213129000.png)

```c
void
kinit()
{
  initlock(&kmem.lock, "kmem");
  freerange(end, (void*)PHYSTOP);
}
```

这里的vstart就是end的地址而vend是`KERNBASE + 128MB` = `0x86400000`

这里就是把[vstart, 0x86400000]的内存按页(4kb大小)进行free

kree`这里会把他插入到`freelist中

```c++
void
freerange(void *vstart, void *vend)
{
  char *p;
  p = (char*)PGROUNDUP((uint)vstart);
  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
    kfree(p);
}
//PAGEBREAK: 21
// Free the page of physical memory pointed at by v,
// which normally should have been returned by a
// call to kalloc().  (The exception is when
// initializing the allocator; see kinit above.)
void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("kfree");

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  r = (struct run*)pa;

  acquire(&kmem.lock);
  r->next = kmem.freelist;
  kmem.freelist = r;
  release(&kmem.lock);
}
```

这里就可以完成整个free操作了

![](image-20210817213005747.png)

（3）jos的boot_alloc函数

当第一次执行的时候nextfree是空这里会进行第一次分配。这里的起始地址也是`end`的地址，然后返回这一段分配的地址，并更新nextfree

```c
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result = NULL;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end + 1, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if (n > 0) {
		result = nextfree;
		nextfree = ROUNDUP(nextfree + n, PGSIZE);
	} else if (n == 0) {
		result = ROUNDUP(nextfree, PGSIZE);
	} else {
		panic("boot_alloc(n): n < 0\n");
	}

	cprintf("boot_alloc(): nextfree=%08x\n", nextfree);

	if ((uintptr_t) nextfree >= KERNBASE + PTSIZE) {
		panic("boot_alloc(): out of memory\n");
	}

	return result;
}
```

kvmmake()

```c
/ Make a direct-map page table for the kernel.
pagetable_t
kvmmake(void)
{
  pagetable_t kpgtbl;

  kpgtbl = (pagetable_t) kalloc();
  memset(kpgtbl, 0, PGSIZE);

  // uart registers
  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

  // virtio mmio disk interface
  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);

  // PLIC
  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);

  // map kernel text executable and read-only.
  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);

  // map kernel data and the physical RAM we'll make use of.
  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);

  // map the trampoline for trap entry/exit to
  // the highest virtual address in the kernel.
  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);

  // map kernel stacks
  proc_mapstacks(kpgtbl);
  
  return kpgtbl;
}
```

kalloc函数

从我们的空闲队列中获得一个指针。返回

```c
void *
kalloc(void)
{
  struct run *r;

  acquire(&kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r->next;
  release(&kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
```

kvmap

1. add a mapping to the kernel page table.
2. only used when booting
3. does not flush TLB or enable paging.

```c
void
kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
{
  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
    panic("kvmmap");
}
```

mappages

1. 给定虚拟地址va和物理地址pa
2. 把[va , va + size]和 [pa, pa + size]进行映射。并且以perm位

```c
static int
mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
{
  char *a, *last;
  pte_t *pte;

  a = (char*)PGROUNDDOWN((uint)va);
  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
  for(;;){
    if((pte = walkpgdir(pgdir, a, 1)) == 0)
      return -1;
    if(*pte & PTE_P)
      panic("remap");
    *pte = pa | perm | PTE_P;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
```

walk函数

在risc-v的xv6中利用39位的虚拟地址。整个原则如下

![](image-20210821174317183.png)

```
// The risc-v Sv39 scheme has three levels of page-table
// pages. A page-table page contains 512 64-bit PTEs.
// A 64-bit virtual address is split into five fields:
//   39..63 -- must be zero.
//   30..38 -- 9 bits of level-2 index.
//   21..29 -- 9 bits of level-1 index.
//   12..20 -- 9 bits of level-0 index.
//    0..11 -- 12 bits of byte offset within the page.

// extract the three 9-bit page table indices from a virtual address.
#define PGSHIFT 12  // bits of offset within a page
#define PXMASK          0x1FF // 9 bits
#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
#define PTE2PA(pte) (((pte) >> 10) << 12)
```

这里的操作用到了上面的`PX`函数

```
#假设 level = 2 
va >> (12 + 9 * 2) & 0x1FF
(va >> 30) & 0x1FF
|EXT|L2| & 0x0001|1111|1111|
# 得到的就是L2的地址
```

这里就是获取指定虚拟地址的pte也就是最后一层的`PPN`

```
pte_t *
walk(pagetable_t pagetable, uint64 va, int alloc)
{
  if(va >= MAXVA)
    panic("walk");

  for(int level = 2; level > 0; level--) {
    pte_t *pte = &pagetable[PX(level, va)];
    if(*pte & PTE_V) {
      pagetable = (pagetable_t)PTE2PA(*pte);
    } else {
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
        return 0;
      memset(pagetable, 0, PGSIZE);
      *pte = PA2PTE(pagetable) | PTE_V;
    }
  }
  return &pagetable[PX(0, va)];
}
```

整个映射完的图如下：

![](image-20210821211420668.png)

（4）kvminithart（）

1. 第一行设置了`satp`这样硬件就可以找到pgdir的地址了

   ```c
   // Switch h/w page table register to the kernel's page table,
   // and enable paging.
   void
   kvminithart()
   {
     w_satp(MAKE_SATP(kernel_pagetable));
     sfence_vma();
   }
   ```

   刷新当前cpu的tlb

   ```c
   // flush the TLB.
   static inline void
   sfence_vma()
   {
     // the zero, zero means flush all TLB entries.
     asm volatile("sfence.vma zero, zero");
   }
   ```

#### 4、执行进程的用户内存![](image-20220927224136110.png)

接下来在r->中自由列表的旧开始，并设置自由列表等于r. kalloc删除并返回自由列表中的第一个元素

#### 5、进程的虚拟内存地址布局以及物理地址内存布局

![](image-20220927224309537.png)



## 实验步骤：

#### 1、修改proc.h，新增pageNum记录为进程用户栈分配的页数

```c
struct proc {
	uint sz;                     // Size of process memory (bytes)
	pde_t* pgdir;                // Page table
	char *kstack;                // Bottom of kernel stack for this process
	enum procstate state;        // Process state
	int pid;                     // Process ID
	struct proc *parent;         // Parent process
	struct trapframe *tf;        // Trap frame for current syscall
	struct context *context;     // swtch() here to run process
	void *chan;                  // If non-zero, sleeping on chan
	int killed;                  // If non-zero, have been killed
	struct file *ofile[NOFILE];  // Open files
	struct inode *cwd;           // Current directory
	char name[16];               // Process name (debugging)
	unsigned int pageNum;
};
```

#### 2、修改exec.c，将栈底移到KERNBASE-1

```c
int
exec(char *path, char **argv)
{
	  char *s, *last;
	  int i, off;
	  uint argc, sz, sp, ustack[3+MAXARG+1];
	  struct elfhdr elf;
	  struct inode *ip;
	  struct proghdr ph;
	  pde_t *pgdir, *oldpgdir;
	  struct proc *curproc = myproc();

	  begin_op();
	
	  if((ip = namei(path)) == 0){
	    end_op();
	    cprintf("exec: fail\n");
	    return -1;
	  }
	  ilock(ip);
	  pgdir = 0;

	  // Check ELF header
	  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
	 	goto bad;
	  if(elf.magic != ELF_MAGIC)
	    goto bad;
	
	  if((pgdir = setupkvm()) == 0)
	    goto bad;

	  // Load program into memory.
	  sz = 0;
	  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
		    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
			      goto bad;
		    if(ph.type != ELF_PROG_LOAD)
			      continue;
		    if(ph.memsz < ph.filesz)
			      goto bad;
		    if(ph.vaddr + ph.memsz < ph.vaddr)
			      goto bad;
		    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
			      goto bad;
		    if(ph.vaddr % PGSIZE != 0)
			      goto bad;
		    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
			      goto bad;
  		}
		iunlockput(ip);
		end_op();
		ip = 0;

		// Allocate two pages at the next page boundary.
		// Make the first inaccessible.  Use the second as the user stack.
		sz = PGROUNDUP(sz);

		//将KERNBASE-1作为栈底
		sp = KERNBASE-1;
		//先分配一页作为用户栈
		if(allocuvm(pgdir, sp - PGSIZE, sp) == 0)
			goto bad;
		clearpteu(pgdir, (char*)(sp - PGSIZE));
		//记录分配情况并输出
		curproc->pageNum=1;
		cprintf("New process %d pageNum: %d\n",curproc->pid,curproc->pageNum);

		// Push argument strings, prepare rest of stack in ustack.
		for(argc = 0; argv[argc]; argc++) {
			if(argc >= MAXARG)
				goto bad;
			sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
			if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
				goto bad;
			ustack[3+argc] = sp;
		}
		ustack[3+argc] = 0;
		
		ustack[0] = 0xffffffff;  // fake return PC
		ustack[1] = argc;
		ustack[2] = sp - (argc+1)*4;  // argv pointer

		sp -= (3+argc+1) * 4;
		if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
			goto bad;
		
		// Save program name for debugging.
		for(last=s=path; *s; s++)
			if(*s == '/')
		 		last = s+1;
		safestrcpy(curproc->name, last, sizeof(curproc->name));
		
		// Commit to the user image.
		oldpgdir = curproc->pgdir;
		curproc->pgdir = pgdir;
		curproc->sz = sz;
		curproc->tf->eip = elf.entry;  // main
		curproc->tf->esp = sp;
		switchuvm(curproc);
		freevm(oldpgdir);
		return 0;
		
		bad:
		if(pgdir)
			freevm(pgdir);
		if(ip){
			iunlockput(ip);
			end_op();
		}
		return -1;
}
```

#### 3、修改syscall.c，将地址越界的范围改为KERNBASE-1

```c
int
fetchint(uint addr, int *ip)
{
  	if(addr >= (KERNBASE-1) || addr+4 > (KERNBASE-1))
    	return -1;
  	*ip = *(int*)(addr);
  	return 0;
}

int
fetchstr(uint addr, char **pp)
{
  	char *s, *ep;
  	if(addr >= (KERNBASE-1))
    	return -1;
  	*pp = (char*)addr;
  	ep = (char*)(KERNBASE-1);
  	for(s = *pp; s < ep; s++){
    	if(*s == 0)
      		return s - *pp;
  	}
  	return -1;
}

int
argptr(int n, char **pp, int size)
{
  	int i;
  	if(argint(n, &i) < 0)
    	return -1;
  	if(size < 0 || (uint)i >= (KERNBASE-1) || (uint)i+size > (KERNBASE-1))
    	return -1;
  	*pp = (char*)i;
  	return 0;
}
```

#### 4、修改vm.c

```c
pde_t*
copyuvm(pde_t *pgdir, uint sz)
{
  	pde_t *d;
  	pte_t *pte;
  	uint pa, i, flags;
  	char *mem;

  	if((d = setupkvm()) == 0)
    	return 0;
  	for(i = 0; i < sz; i += PGSIZE){
    	if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
      		panic("copyuvm: pte should exist");
    	if(!(*pte & PTE_P))
      		panic("copyuvm: page not present");
    	pa = PTE_ADDR(*pte);
    	flags = PTE_FLAGS(*pte);
    	if((mem = kalloc()) == 0)
      		goto bad;
    	memmove(mem, (char*)P2V(pa), PGSIZE);
    	if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
      		kfree(mem);
      		goto bad;
    	}
  	}
  
  	//再加一轮循环用于复制用户栈，范围为从栈底到栈顶，栈顶由栈底减去分配的页数乘一页尺寸得到
  	struct proc* curproc = myproc();
  	uint stackBottom = KERNBASE - 1;
  	stackBottom = PGROUNDDOWN(stackBottom);
  	for(i = stackBottom; i > (stackBottom - curproc->pageNum * PGSIZE); i -= PGSIZE){
    	if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
      		panic("copyuvm: pte should exist");
    	if(!(*pte & PTE_P))
      		panic("copyuvm: page not present");
    	pa = PTE_ADDR(*pte);
    	flags = PTE_FLAGS(*pte);
    	if((mem = kalloc()) == 0)
      		goto bad;
    	memmove(mem, (char*)P2V(pa), PGSIZE);
    	if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
      		kfree(mem);
      		goto bad;
    	}
 	}  

  	return d;

	bad:
  	freevm(d);
  	return 0;
}
```

#### 5、修改proc.c，在fork()中将父进程分配页数赋值给子进程页数

```C
int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *curproc = myproc();

  // Allocate process.
  if((np = allocproc()) == 0){
    return -1;
  }

  // Copy process state from proc.
  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
    kfree(np->kstack);
    np->kstack = 0;
    np->state = UNUSED;
    return -1;
  }
  np->sz = curproc->sz;
  np->parent = curproc;
  *np->tf = *curproc->tf;
  
  //将父进程分配页数赋值给子进程
  np->pageNum = curproc->pageNum;

  // Clear %eax so that fork returns 0 in the child.
  np->tf->eax = 0;

  for(i = 0; i < NOFILE; i++)
    if(curproc->ofile[i])
      np->ofile[i] = filedup(curproc->ofile[i]);
  np->cwd = idup(curproc->cwd);

  safestrcpy(np->name, curproc->name, sizeof(curproc->name));

  pid = np->pid;

  acquire(&ptable.lock);

  np->state = RUNNABLE;

  release(&ptable.lock);

  return pid;
}
```

#### 6、修改trap.c，添加case T_PGFLT，实现用户栈增长

```C
void
trap(struct trapframe *tf)
{
  if(tf->trapno == T_SYSCALL){
    if(myproc()->killed)
      exit();
    myproc()->tf = tf;
    syscall();
    if(myproc()->killed)
      exit();
    return;
  }

  switch(tf->trapno){
  case T_IRQ0 + IRQ_TIMER:
    if(cpuid() == 0){
      acquire(&tickslock);
      ticks++;
      wakeup(&ticks);
      release(&tickslock);
    }
    lapiceoi();
    break;
  case T_IRQ0 + IRQ_IDE:
    ideintr();
    lapiceoi();
    break;
  case T_IRQ0 + IRQ_IDE+1:
    // Bochs generates spurious IDE1 interrupts.
    break;
  case T_IRQ0 + IRQ_KBD:
    kbdintr();
    lapiceoi();
    break;
  case T_IRQ0 + IRQ_COM1:
    uartintr();
    lapiceoi();
    break;
  case T_IRQ0 + 7:
  case T_IRQ0 + IRQ_SPURIOUS:
    cprintf("cpu%d: spurious interrupt at %x:%x\n",
            cpuid(), tf->cs, tf->eip);
    lapiceoi();
    break;
    
  //处理用户栈不足时的错误
  case T_PGFLT:;
  	//获取出错地址
    uint falseAddress = rcr2();
    if(falseAddress > KERNBASE - 1)
		exit();
    falseAddress = PGROUNDDOWN(falseAddress);
    //每次分配一页
    if(allocuvm(myproc()->pgdir, falseAddress, falseAddress + PGSIZE) == 0){
		cprintf("Alloc new page error.\n");
		exit();
    }
    //输出分配结果
    myproc()->pageNum++;
    cprintf("Alloc new page. %d current pageNum: %d\n",myproc()->pid, myproc()->pageNum);
    break;

  //PAGEBREAK: 13
  default:
    if(myproc() == 0 || (tf->cs&3) == 0){
      // In kernel, it must be our mistake.
      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
              tf->trapno, cpuid(), tf->eip, rcr2());
      panic("trap");
    }
    // In user space, assume process misbehaved.
    cprintf("pid %d %s: trap %d err %d on cpu %d "
            "eip 0x%x addr 0x%x--kill proc\n",
            myproc()->pid, myproc()->name, tf->trapno,
            tf->err, cpuid(), tf->eip, rcr2());
    myproc()->killed = 1;
  }

  // Force process exit if it has been killed and is in user space.
  // (If it is still executing in the kernel, let it keep running
  // until it gets to the regular system call return.)
  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
    exit();

  // Force process to give up CPU on clock tick.
  // If interrupts were on while locks held, would need to check nlock.
  if(myproc() && myproc()->state == RUNNING &&
     tf->trapno == T_IRQ0+IRQ_TIMER)
    yield();

  // Check if the process has been killed since we yielded
  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
    exit();
}

```

#### 7、编写用户级程序recursive.c，实现多层递归

```c
#include"types.h"
#include"user.h"
#include "stat.h"

#pragma GCC push_options
#pragma GCC optimize ("O0")

int 
factorial(int n)
{
    if(n < 0)
        return 0;
    else if(n == 0)
        return 1;
    else
        return n *factorial(n-1);
}

#pragma GCC pop_options

int 
main(int argc, char* argv[])
{
    if(argc != 2)
        exit();
    int num;
    num = atoi(argv[1]);
    factorial(num);
    exit();
}
```

#### 8、编译运行结果

![](image-20220927154434769.png)

*为进程1和进程2各分配一页用户栈*

![](image-20220927155729102.png)

*实现用户栈的增长*
